from datetime import datetime
from flask import render_template, flash, redirect, url_for, request
from flask_login import login_user, logout_user, current_user, login_required
from werkzeug.urls import url_parse
from app import app, db
from app.forms import LoginForm, RegistrationForm, EditProfileForm, PostForm
from app.models import User, Post
from app.forms import ResetPasswordRequestForm, ResetPasswordForm
from app.email import send_password_reset_email

'''
These routes are know as the view function
Note the 'Post/Redirect/Get' pattern (even redirect to the same page). This avoids inserting 
duplicate posts when a user refreshes the page after submitting a web form.

The render_template() function invokes the Jinja2 template engine that comes bundled 
with the Flask framework. Jinja2 substitutes {{ ... }} blocks in the template with the 
corresponding values, given by the arguments provided in the render_template() call.
'''

@app.before_request
def before_request():
    '''
    The @before_request decorator from Flask register the decorated function to be executed right 
    before the view function. This is extremely useful because now I can insert code that I want 
    to execute before any view function in the application, and I can have it in a single place. 
    The implementation simply checks if the current_user is logged in, and in that case sets the 
    last_seen field to the current time. 
    '''
    if current_user.is_authenticated:
        current_user.last_seen = datetime.utcnow()
        # the reason db.session.add() is not located here is b/c current_user indicates the database
        # has already been queried that will add the user to the database session.
        db.session.commit()


# SCAFOLDING EXAMPLE SCRIPT
# @app.route('/')
# @app.route('/index') # default method only includes 'GET'
# @login_required
# def index():
#     posts = [
#         {'author': {'username': 'Miguel'},'body': 'Some beautiful text'},
#         {'author': {'username': 'Susan B'}, 'body': 'Susan B Anthony is the GREATEST!'}
#     ]

#     return render_template('index.html', title='Home', posts=posts)

@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    '''
    first, import Post and PostForm classes. Next, accepts POSTS in both routes associated with the index view
    function (in addt to GET reqs). This view function will now accept form data. Then form processing logic 
    inserts a new post record into the database. Finally, send the form to render the template.
    '''
    form = PostForm()
    if form.validate_on_submit():
        post = Post(body=form.post.data, author=current_user)
        db.session.add(post)
        db.session.commit()
        flash('Your post is now live!')
        return redirect(url_for('index'))
        # So, why the redirect here? It is a standard practice to respond to a POST request generated by a web form 
        # submission with a redirect. Refreshes the browser. This simple trick is called the Post/Redirect/Get pattern. 
        
    # posts = current_user.followed_posts().all() # get all posts prior to pagination
    page = request.args.get('page', 1, type=int)
    posts = current_user.followed_posts().paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    next_url = url_for('index', page=posts.next_num) \
        if posts.has_next else None
    prev_url = url_for('index', page=posts.prev_num) \
        if posts.has_prev else None
    return render_template('index.html', title='Home', form=form,
                           posts=posts.items, next_url=next_url,
                           prev_url=prev_url)
    # SCAFFOLDING
    # posts = [
    #     {'author': {'username': 'Miguel'},'body': 'Some beautiful text'},
    #     {'author': {'username': 'Susan B'}, 'body': 'Susan B Anthony is the GREATEST!'}
    # ]


    return render_template("index.html", title='Home Page', form=form,
                           posts=posts)



@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    form = LoginForm()
    if form.validate_on_submit():
        # SCAFFOLDING
        # user = {'username', 'Michael'}
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash('Invalid username or password')
            return redirect(url_for('login'))
        login_user(user, remember=form.remember_me.data)
        next_page = request.args.get('next')
        if not next_page or url_parse(next_page).netloc != '':
            next_page = url_for('index')
        return redirect(next_page)
    return render_template('login.html', title='Sign In', form=form)


@app.route('/logout')
def logout():
    logout_user()
    return redirect(url_for('index'))


@app.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    form = RegistrationForm()
    if form.validate_on_submit():
        user = User(username=form.username.data, email=form.email.data)
        user.set_password(form.password.data)
        db.session.add(user)
        db.session.commit()
        flash('Congratulations, you are now a registered user!')
        return redirect(url_for('login'))
    return render_template('register.html', title='Register', form=form)

'''
When a route has a dynamic component (e.g. <>), Flask will accept any text in that portion 
of the URL, and will invoke the view function with the actual text as an argument. For 
example, if the client browser requests URL /user/susan, the view function is going to be 
called with the argument username set to 'susan'. 
'''
@app.route('/user/<username>')
@login_required
def user(username):
    # SCAFOLDING
    # user = User.query.filter_by(username=username).first_or_404() # sends a 404 if no match
    # # other query options include .first() and .all()
    # # returns user object with attributes of field names in the database
    # posts = [
    #     {'author': user, 'body': 'Test post #1'},
    #     {'author': user, 'body': 'Test post #2'}
    # ]
    # # posts = User.query.
    # return render_template('user.html', user=user, posts=posts)

    user = User.query.filter_by(username=username).first_or_404()
    page = request.args.get('page', 1, type=int)
    posts = user.posts.order_by(Post.timestamp.desc()).paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    next_url = url_for('user', username=user.username, page=posts.next_num) \
        if posts.has_next else None
    prev_url = url_for('user', username=user.username, page=posts.prev_num) \
        if posts.has_prev else None
    return render_template('user.html', user=user, posts=posts.items,
                           next_url=next_url, prev_url=prev_url)


@app.route('/edit_profile', methods=['GET', 'POST'])
@login_required
def edit_profile():
    form = EditProfileForm(current_user.username) # allows error caused by selecting same username
    # as someone else to be resolved without interference if you enter your current username
    if form.validate_on_submit(): # only returns true if a POST method AND information is validated
        current_user.username = form.username.data
        current_user.about_me = form.about_me.data
        db.session.commit()
        flash('Your changes have been saved.') # sends text to the flash section of the base template
        return redirect(url_for('edit_profile'))
    elif request.method == 'GET': # if the client is GET info (i.e. first directed to the URL)
        form.username.data = current_user.username # fill in the fields with previously entered data
        form.about_me.data = current_user.about_me # from the database
    return render_template('edit_profile.html', title='Edit Profile',
                           form=form)


@app.route('/explore')
@login_required
def explore():
    '''
    Notice the index.html template is reused from '/index' however, there is no form and the posts are not filtered
    '''
    # SCAFFOLDING
    # posts = Post.query.order_by(Post.timestamp.desc()).all()

    page = request.args.get('page', 1, type=int)
    posts = Post.query.order_by(Post.timestamp.desc()).paginate(
        page, app.config['POSTS_PER_PAGE'], False)
    next_url = url_for('explore', page=posts.next_num) \
        if posts.has_next else None
    prev_url = url_for('explore', page=posts.prev_num) \
        if posts.has_prev else None
    return render_template("index.html", title='Explore', posts=posts.items,
                          next_url=next_url, prev_url=prev_url)



@app.route('/follow/<username>')
@login_required
def follow(username):
    user = User.query.filter_by(username=username).first()
    if user is None:
        flash('User {} not found.'.format(username))
        return redirect(url_for('index'))
    if user == current_user:
        flash('You cannot follow yourself!')
        return redirect(url_for('user', username=username))
    current_user.follow(user)
    db.session.commit()
    flash('You are following {}!'.format(username))
    return redirect(url_for('user', username=username))

@app.route('/unfollow/<username>')
@login_required
def unfollow(username):
    user = User.query.filter_by(username=username).first()
    if user is None:
        flash('User {} not found.'.format(username))
        return redirect(url_for('index'))
    if user == current_user:
        flash('You cannot unfollow yourself!')
        return redirect(url_for('user', username=username))
    current_user.unfollow(user)
    db.session.commit()
    flash('You are not following {}.'.format(username))
    return redirect(url_for('user', username=username))


@app.route('/reset_password_request', methods=['GET', 'POST'])
def reset_password_request():
    '''
    After the email is sent, I flash a message directing the user to look for the email for further 
    instructions, and then redirect back to the login page. You may notice that the flashed message 
    is displayed even if the email provided by the user is unknown. This is so that clients cannot 
    use this form to figure out if a given user is a member or not.
    '''
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    form = ResetPasswordRequestForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        if user:
            send_password_reset_email(user)
        flash('Check your email for the instructions to reset your password')
        return redirect(url_for('login'))
    return render_template('reset_password_request.html',
                           title='Reset Password', form=form)


@app.route('/reset_password/<token>', methods=['GET', 'POST'])
def reset_password(token):
    if current_user.is_authenticated: #Make sure user isn't logged in
        return redirect(url_for('index'))
    user = User.verify_reset_password_token(token) # verify token returning user
    if not user:
        return redirect(url_for('index')) # if the token was not verified, returned None
    form = ResetPasswordForm()
    if form.validate_on_submit():
        user.set_password(form.password.data)
        db.session.commit()
        flash('Your password has been reset.')
        return redirect(url_for('login'))
    return render_template('reset_password.html', form=form)